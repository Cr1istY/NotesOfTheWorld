# C++入门教程

## 一、导学，关于C++

### 面向过程和面向对象

c语言最大的缺陷，就是在于他面向过程的思维，在如今看来不够高效。

因此，面向对象的cpp语言应运而生。

#### 面向过程（POP）

- 以过程（procedure）为中心的编程范式
- 按照计算机执行命令的顺序，从上到下顺序设计程序

#### 面向对象（OOP）

- 以对象（object）为核心的编程范式
- 对象是类（class）的实例，类中包括了数据的定义和对数据的操作方法

### C++的特点

- 贴近底层、运行速度快
- 编译型语言
- 静态类型语言
- 结构化教学语言
- 面向对象语言
- 面向泛式编程语言
- 功能强大，也复杂、难以掌握

### C++的应用领域

- 桌面应用
- 系统开发
- 底层架构
- 游戏开发
- **嵌入式开发**

### C++代码运行和标准

#### 编译型语言

将整个源代码编译成机器码，再运行机器码

例如：C++、C

#### 解释型语言

由解释器将代码逐行翻译成机器码，逐行运行

例如：Python、JavaScript

#### C++运行

1. 将源代码编译成可目标代码
1. 目标代码与库文件链接，生成可执行文件
1. 运行可执行文件

#### C++标准

- C++98
- C++03
- C++11
- C++14
- C++17
- C++20

## 二、正式开始

### 1.第一个C++程序

```cpp
#include <iostream>

int main() {
	std::cout << "Hello, World!" << std::endl;
	return 0;
}
```

- std 命名空间
- :: 作用域运算符

### 2.变量和数据类型

#### 变量的声明和赋值
```cpp
// 数据类型 变量名 = 初始值;
int a = 10;
```

#### 标识符

由字母、数字、下划线组成，不能以数字开头

不能使用关键字命名

常使用驼峰命名法命名

#### 常量

- 使用`#define`定义常量，不推荐
- 使用`const + 数据类型`定义常量

#### 整形

| 类型 | 描述 | 字节数 | 范围 |
| --- | --- | --- | --- |
| int | 整数 | 4 | -2147483648 ~ 2147483647 |
| short | 短整数 | 2 | -32768 ~ 32767 |
| long | 长整数 | 4 | -2147483648 ~ 2147483647 |
| long long | 长长整数 | 8 | -9223372036854775808 ~ 9223372036854775807 |
| unsigned int | 无符号整数 | 4 | 0 ~ 4294967295 |
|char|字符|1|-128 ~ 127|
|bool|布尔|1|true/false|

使用原则：

1. int不够用，直接使用long long
1. 不能为负直接使用unsigned

#### 浮点型

| 类型 | 描述 | 字节数 | 范围 |
| --- | --- | --- | --- |
| float | 单精度浮点数 | 4 | 3.4e-38 ~ 3.4e38 |
| double | 双精度浮点数 | 8 | 1.7e-308 ~ 1.7e308 |

还可以使用科学计数法表示

5.2e2 = 5.2 * 10^2 = 520

### 3.运算符

#### 优先级

乘除运算大于加减运算，平级从左往右依次计算，括号优先级最高

#### 算术运算符

|运算符|功能|
|---|---|
|+|加法、表示正数|
|-|减法、表示负数|
|*|乘法|
|/|除法|
|%|求余、取模|

#### 赋值运算符

用“=”号表示赋值

左值必须是可以修改的变量，右值可以是常量、变量、表达式

同时，在c++中，可以使用{}进行初始化赋值
```cpp
int a = {10};
int a = 10;
```
两者等效

#### 复合赋值运算符

```cpp
sum+= 10;
sum/= 10;
```
本质上都是二合一，即将运算符和赋值运算符合并

同时，还有`++a` `--b`等常见操作

值得注意的是：

`++a`前置时，先运算再进行返回

`a++`后置式，先返回再运算

#### 关系运算符

|运算符|功能|
|---|---|
|==|等于|
|!=|不等于|
|>|大于|
|<|小于|
|>=|大于等于|
|<=|小于等于|

#### 逻辑运算符

|运算符|功能|
|---|---|
|&&|与|
|\|\||或|
|!|非|

#### 条件运算符
```cpp
int a = 10;
int b = 20;
int max = a > b ? a : b;
```
等效于
```cpp
int max;
if (a > b) {
	max = a;
} else {
	max = b;
}
```

即 ，`?`前为判断条件，`:`前为条件为真时返回值，`:`后为条件为假时返回值

#### 位运算符

位运算符操作的是每一位（bit）上的数据

|运算符|功能|
|---|---|
|&|按位与|
|\||按位或|
|^|按位异或|
|~|按位取反|
|<<|左移|
|>>|右移|

#### 类型转换

- 隐式类型转换
> - 将长度较小的数据类型转换为长度较大的数据类型
> - 这样可以避免精度丢失

- 显式类型转换（强制类型转换）
```cpp
int a = 10;
double b = (double)a;
double c = double(a);
static_cast<double>(a);
```

(数据类型)变量 | 数据类型(变量) | 使用c++内置强制类型转换函数

### 4.流程控制语句

#### 顺序结构

程序按照代码的先后顺序执行

#### 分支结构

##### if

1. if单分支

```cpp
if (条件) {
	// 代码块
}
```

2. if双分支(也可使用条件运算符)

```cpp
if(条件) {
	// 代码块
} else {
	// 代码块
}
```

3. if多分支
```cpp
if (条件1) {
	// 代码块
} else if (条件2) {
	// 代码块
} else {
	// 代码块
}
```

##### switch
```cpp
switch (表达式) {
	case 常量1:
		// 代码块
		break;
	case 常量2:
		// 代码块
		break;
	default:
		// 代码块
}
```

用于多分支判断，`break`用于跳出`switch`语句

#### 循环（迭代）结构

##### while
```cpp
while (条件) {
	// 代码块
}
```

##### do while
```cpp
do {
	// 代码块
} while (条件);
```

先执行一次循环体，再判断条件

##### for
```cpp
for (初始化; 条件; 更新) {
	// 代码块
}
```

**范围for循环**
```cpp
int arr[5] = {1, 2, 3, 4, 5};
for (int i : arr) {
	std::cout << i << std::endl;
}
```

#### 跳转

##### break
跳出循环

##### continue
跳过本次循环

##### goto和return
跳转到指定位置
```cpp
goto label;
label:
```

goto一般不使用，会导致程序逻辑混乱

return终止函数运行，并返回值

### 5.复合数据类型

#### 数组

- 在内存中开辟一段连续的空间
- 一组相同类型的数据集合
- 通过下标访问数组元素
- 数组下标从0开始
- 元素个数不能为变量
```cpp
int arr[5] = {1, 2, 3, 4, 5};
```

##### 访问和遍历数组
```cpp
for (int i = 0; i < 5; i++) {
	std::cout << arr[i] << std::endl;
}
```

#### 多维数组

c++支持多维数组，但是不推荐使用

多维数组本质上是数组的数组

```cpp
int arr[2][3] = {
	{1, 2, 3},
	{4, 5, 6}
};
```

##### arry模板类

对于固定大小的数组，推荐使用array模板类
```cpp
#include <array>
std::array<int, 5> arr = {1, 2, 3, 4, 5};
```

#### 模板类vector

vector是c++标准库中的容器，可以动态调整大小

```cpp
#include <vector>
std::vector<int> v;
v.push_back(10);
v.push_back(20);
```

##### 添加元素

可以使用 push_back 方法向 vector 中添加元素：

```cpp
myVector.push_back(7); // 将整数 7 添加到 vector 的末尾
```

##### 访问元素

可以使用下标操作符 [] 或 at() 方法访问 vector 中的元素：

```cpp
int x = myVector[0]; // 获取第一个元素
int y = myVector.at(1); // 获取第二个元素
```

##### 获取大小

可以使用 size() 方法获取 vector 中元素的数量：

```cpp
int size = myVector.size(); // 获取 vector 中的元素数量
```

##### 迭代访问

可以使用迭代器遍历 vector 中的元素：

```cpp
for (auto it = myVector.begin(); it != myVector.end(); ++it) {
    std::cout << *it << " ";
}

```
或者使用范围循环：

```cpp
for (int element : myVector) {
    std::cout << element << " ";
}
```

##### 删除元素

可以使用 erase() 方法删除 vector 中的元素：

```cpp
myVector.erase(myVector.begin() + 2); // 删除第三个元素
```

##### 清空 Vector

可以使用 clear() 方法清空 vector 中的所有元素：

```cpp
myVector.clear(); // 清空 vector
```

#### 字符串string

所谓的字符串，本质上是一个字符数组

c++中提供了string类，用于处理字符串
```cpp
#include <string>
std::string str = "Hello, World!";
```

##### 读取键盘输入
```cpp
std::string str;
std::cin >> str;
```

忽略开始的空白字符，直到遇到下一个空白字符（空格、回车、制表符）为止

##### 读取一行
```cpp
std::string str;
std::getline(std::cin, str);
```

读取一行，直到遇到回车为止

##### 使用get
```cpp
std::string str;
std::cin.get(str);
std::str = cin.get();
```

#### 读取文件
```cpp
#include <fstream>
std::ifstream ifs("test.txt");
std::string str;
ifs >> str;
```

##### 逐词读取
```cpp
std::string word;
while (ifs >> word) {
	std::cout << word << std::endl;
}
```

##### 逐行读取
```cpp
std::string line;
while (std::getline(ifs, line)) {
	std::cout << line << std::endl;
}
```

##### 逐个字符读取
```cpp
char c;
	while (ifs.get(c)) {
	std::cout << c;
}
```

#### 写入文件
```cpp
#include <fstream>
std::ofstream ofs("test.txt");
std::string str = "Hello, World!";
ofs << str;
```

## 三、进阶

### 结构体

结构体是一种自定义数据类型，用于存储不同类型的数据
```cpp
struct Student {
	std::string name;
	int age;
	double score;
};
```

#### 结构体变量
```cpp
Student stu = {"张三", 18, 99.5};
```

#### 结构体数组

```cpp
Student stus[3] = {
{"张三", 18, 99.5},
{"李四", 19, 98.5},
{"王五", 20, 97.5}
};
```

### 结构体访问

#### 结构体成员访问

```cpp
std::cout << stu.name << std::endl;
```

#### 结构体指针访问

```cpp
Student *p = &stu;
std::cout << p->name << std::endl;
```

### 枚举

枚举是一种自定义数据类型，用于定义一组具名的整数常量

```cpp
enum Season {
Spring,
Summer,
Autumn,
Winter
};
```

#### 枚举变量

```cpp
Season s = Spring;
```

```cpp
std::cout << Spring << std::endl;
```

### 指针

指针是一个变量，存储另一个变量的地址

指针是指向另一种数据类型的数据类型

#### 指针变量

```cpp
int a = 10;
int *p = &a;
```

& 取地址运算符

`*` 间接访问运算符

#### 野指针、空指针和void指针

- 野指针：指向未知内存的指针（未初始化的指针）非常危险
- 空指针：指向空地址的指针，通常用于初始化指针变量
- void指针：通用指针类型，可以指向任何类型的数据

```cpp
int *p = nullptr; // 定义空指针
void *p = nullptr; // 定义void指针
```

#### 指针的指针

指针的指针是指一个指针指向另一个指针的地址

```cpp
int a = 10;
int *p = &a;
int **pp = &p;
```

#### 指向常量的指针

指向常量的指针不能通过指针修改变量的值

```cpp
const int a = 10;
const int *p = &a;
```

#### 常量指针

常量指针不能修改指针指向的地址

```cpp
int a = 10;
int *const p = &a;
```

#### 指针和数组

指针和数组是密切相关的，数组名是数组首元素的地址

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;
```

p指向arr的首元素

#### 指针运算

指针可以进行加减运算，但是不能进行乘除运算

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;
p++;
```

p++表示指针向后移动一个元素

#### 指针数组和数组指针

指针数组是一个数组，数组中的元素是指针

```cpp
int a = 10;
int b = 20;
int c = 30;
int *arr[3] = {&a, &b, &c};
```

数组指针是一个指针，指向一个数组

```cpp
int arr[3] = {1, 2, 3};
int (*p)[3] = &arr;
```

### 引用

引用是一个变量的别名，引用和原变量共享同一块内存空间

一旦引用被初始化，就不能再引用其他变量

#### 引用变量

```cpp
int a = 10;
int &b = a;
```

#### 引用的引用

引用的引用是指一个引用指向另一个引用

```cpp
int a = 10;
int &b = a;
int &c = b;
```

#### 对常量的引用

对常量的引用不能通过引用修改变量的值

```cpp
const int a = 10;
const int &b = a;
```

#### 指针和引用

- 指针可以为空，引用不能为空
- 指针可以改变指向，引用不能改变引用对象
- 指针可以进行加减运算，引用不能进行运算
- 指针需要解引用才能访问值，引用不需要解引用
- 指针和引用的大小不同
- 指针和引用的初始化方式不同
- 指针和引用的作用域不同
- 指针和引用的用途不同
- 指针和引用的传递方式不同

### 6.函数

#### 函数的定义和调用

函数是一段具有特定功能的、可重复使用的代码块

函数的定义包括函数头和函数体

函数的调用是指在程序中使用函数的名称来执行函数中的代码

#### 生命周期和静态对象

生命周期是指对象在内存中的存在时间

自动对象：

- 是在程序执行到定义它的语句时创建，在程序执行到定义它的语句所在的代码块结束时销毁的对象

- 生命周期与代码块的生命周期相同

静态对象：

- 是在程序开始执行时创建，在程序结束时销毁的对象

- 生命周期与程序的生命周期相同

- 作用域是整个程序

- 存储位置是静态存储区

- 初始化是在程序开始执行时进行的

#### 函数的声明

函数的声明是指在程序中使用函数的名称来声明函数的存在，但是不包含函数的定义

函数的声明可以放在程序的任何位置，但是必须在函数被调用之前进行

#### 头文件与分离式编译

头文件是指包含函数声明的文件，通常以.h为后缀

使用`#include "头文件.h"`引入头文件

头文件需要使用`#pragma once`防止重复引入

#### 函数的参数

函数的参数是指调用函数时传递给函数的数据

函数的参数可以是常量、变量、表达式、数组、结构体、指针、引用等

##### 值传递

值传递是指将实参的值传递给形参

值传递是一种单向传递，实参的值传递给形参，形参的值不会传递给实参

```cpp
void swap(int a, int b) {
	int temp = a;
	a = b;
	b = temp;
}
```

##### 地址传递

地址传递是指将实参的地址传递给形参

地址传递是一种双向传递，形参的值会传递给实参

```cpp
void swap(int *a, int *b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
```

##### 引用传递

引用传递是指将实参的引用传递给形参

引用传递是一种双向传递，形参的值会传递给实参

```cpp
void swap(int &a, int &b) {
	int temp = a;
	a = b;
	b = temp;
}
```

##### 数组形参

数组形参是指将数组名传递给函数

数组形参是指针形参，传递的是数组的首地址

```cpp
void print(int arr[], int len) {
	for (int i = 0; i < len; i++) {
		std::cout << arr[i] << std::endl;
	}
}
```

#### 函数的返回值

##### 无返回值

##### 有返回值

### 7.函数的高阶应用

#### 内联函数

用函数的代码，替代函数调用

```cpp
inline int add(int a, int b) {
	return a + b;
}
```

#### 默认实参

函数的参数可以有默认值

但是只要一个参数定义了默认值，其余的参数都需要被赋值

```cpp
string stuInfo(string name = "111", string hello = "hello") {
	string info = "name:" + name "\thello" + hello;
	return info;
}
```

#### 函数重载

在c++中，同一作用域下，同一个函数名是可以被定义多次的，前提是参数列表不同。

这种，函数名相同，但实际上不同的函数被称为“重载函数”。

**主函数不能被重载**

#### 有const形参时的函数重载

常量作为形参时，跟不加const完全等价

```cpp

```

#### 函数匹配

函数匹配是指编译器根据函数调用的参数，选择合适的函数进行调用

可以根据传入的参数类型、个数、顺序等进行匹配

#### 函数指针

函数指针是指指向函数的指针

函数指针可以指向函数的地址，通过函数指针调用函数
```cpp
int add(int a, int b) {
	return a + b;
}
int (*p)(int, int) = add;
```

##### 函数指针作形参

```cpp
void print(int (*p)(int, int)) {
	std::cout << p(10, 20) << std::endl;
}
```

### 8.面向对象

#### 类和对象

##### 封装

封装是指将数据和操作数据的函数封装在一起，形成一个类

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制，提高安全性

访问权限：

- 公有权限：public - 可以在类的内部和外部访问
- 私有权限：private - 只能在类的内部访问
- 保护权限：protected - 只能在类的内部和子类中访问

##### 类的声明和定义

```cpp
class Student {
public:
	std::string name;
	int age;
	double score;
	void show();
};
```

在struct中，成员默认是公有的，而在class中，成员默认是私有的

##### 类的成员函数

类的成员函数是指在类中定义的函数

类的成员函数可以访问类的私有成员

```cpp
void Student::show() {
	std::cout << name << "\t" << age << "\t" << score << std::endl;
}
```

一般来说，一般将类的属性设置为私有，而通过公有的成员函数来访问属性

#### 类的对象特性
