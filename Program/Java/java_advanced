# java 进阶

[尚硅谷java下](https://www.bilibili.com/video/BV1JZ421a7PX?spm_id_from=333.788.videopod.episodes&vd_source=1925e38de9174c77ef2d3cfdc2dea75d&p=96)

## 模块十二 - 面向对象其他

### 权限修饰符

1. public - 公有，任何地方都可以访问
2. protected - 保护，本包及其子类可以访问
3. default - 默认，本包可以访问
4. private - 私有，只有本类可以访问

|修饰符|public|protected|default|private|
|:---:|:---:|:---:|:---:|:---:|
|同类|√|√|√|√|
|同包不同类|√|√|√|No|
|不同包子父类|√|√|No|No|
|不同包非子父类|√|No|No|No|

编写代码时，推荐

- 属性用private - 封装思想
- 成员方法使用public - 便于调用
- 构造public - 便于new对象

### final关键字

final：最终的，可以用于

- 修饰类：不能被继承（太监类）
- 修饰方法：不能被重写
- 修饰成员变量：不能被修改
- 修饰局部变量：保证变量的线程安全
- 修饰一个对象：不能改变对象的引用，但可以改变其中的属性

abstract不能和final同时使用

### 代码块

#### 构造代码块

构造代码块每次都会优先于构造方法执行

```java
{

}
```

每new一次，执行一次

#### 静态代码块

```java
static{

}
```

静态代码块只会执行一次，在类加载时执行，且优先于静态成员变量和静态方法执行，且优于构造代码块（最先执行）

#### 静态代码块使用场景

如果想让一些数据最先初始化，那么就可以使用静态代码块

### 内部类

在类里面定义的类

当一个事物的内部，还有一部分需要完整的结构去描述，而这个内部的完整结构又只为外部事物提供服务，那么整个内部的完成结构最好使用内部类

例如，人类中，可以添加一个心脏类

分类：

1. 成员内部类
2. 局部内部类
3. **匿名内部类**

#### 静态成员内部类

格式：直接在定义的时候，加上static关键字

```java
public class Outer {
    public static class Inner {

    }
}
```

注意：

1. 内部类可以定义属性、方法、构造等。
2. 静态内部类可以被final或者abstract修饰。
   1. 被final修饰后，不能被继承
   2. 被abstract修饰后，不能被实例化（new）
3. 静态内部类不能调用外部的非静态成员
4. 内部类还可以被四种权限修饰符修饰。

调用**静态**内部类成员：

```java
Outer.Inner inner = new Outer.Inner();
```

调用**非静态**内部类成员：

```java
Outer.Inner inner = new Outer().new Inner();
```

#### 内部类重名问题

#### 局部内部类问题

#### 内部类，接口和抽象类和普通类作为方法参数和返回值

##### 接口作为参数和返回值

接口作为参数传递，实参传进实现类对象

接口作为返回值，返回实现类对象，用接口对象接受

##### 抽象类作为参数和返回值

抽象类作为参数传递，实参传进抽象类子类对象

抽象类作为方法返回值的情况，需要返回一个实现抽象类所有抽象方法的子类对象

##### 类作为参数和返回值

会经常碰到调用的方法要接收的是一个类类型的情况，那么这时，要向方法中传入该类的对象

会经常碰到返回一个类类型的返回值，那么这时，该方法要返回一个该类的对象

#### 局部内部类实际操作

局部内部类是定义在外部类的局部位置，且一定要有类名；

#### 匿名内部类

匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。

所谓的匿名内部类，就是没有显式声明出类名的内部类

问题：单纯使用一次接口中的方法

1. 创建实现类，实现接口
2. 重写方法
3. 创建实现类对象
4. 调用方法

如果只想使用一次接口中的方法，那么就可以使用匿名内部类

将上面四步四合一

将匿名类当作一种格式

```java
new 接口/抽象类(){
    重写方法
}.重写方法();

// 上面为匿名，下面为有名

类名 对象名 = new 接口/抽象类(){
    重写方法
}
对象名.重写方法();
```

## 模块十三 - 异常_Object

### API文档

API：Application Programming Interface，**应用程序编程接口**，就是接口，就是定义了接口的类，就是接口类

说白了，API就是定义出来的类、接口，以及其中的方法

API文档，就是方便使用者使用的文档，是程序员的“字典”

### 异常

#### 异常的介绍

代码出现了不正常的现象，就叫做异常

Error ：错误 代码出现了重大错误，需要重写

Exception ：异常 代码出现了异常，可以处理，也可以不处理

1. 编译时异常：编译时出现的错误，编译器会提醒，但是不会导致程序无法运行
2. 运行时异常：运行时出现的错误，编译器不会提醒，但是会终止程序运行，导致程序崩溃

当虚拟机运行时，如果代码中出现了异常，那么虚拟机会将异常对象创建出来，并交给JVM处理

最后，抛出异常信息，终止程序

#### 创建异常对象

创建异常对象，只是为了日后学习如何处理异常

关键字：`throw`

```java
throw new 异常类();
```

#### 处理异常

使用关键字：`throws`

##### 异常处理方式一 throws

```java
throw 异常;
```

```java
public class Demo01Throws {
    public static void main(String[] args) throws Exception {
        System.out.println(10/0);
        System.out.println("程序继续执行");
    }
}
```

1. 格式：在方法参数和方法体之间位置写上
2. 处理异常，将异常往上抛

如果`throws`抛出多个异常的时候呈父子类关系，可以直接抛出父类（直接`throws Exception`）

##### 异常处理方式二 try-catch-finally

```java
try{
    可能出现异常的代码
}catch(异常类名 e){
    处理有异常的代码 ->  将来会将异常信息保存到日志文件中
}
```

e是自定义的对象名

日志文件，用来保存使用程序的错误信息以及使用信息

##### 多个catch

对于不同的异常，使用不同的catch处理

把异常类名换成不同的异常类名，实现多个catch以应对不同的异常情况

#### finally关键字

代表不管是否触发异常，都会执行的代码块

**即便return也会执行finally**，除非有system.exit(0)

##### finally使用场景

1. 关闭资源
2. 释放资源，如果对象没有用了，GC会自动回收，而有一些对象是不能被GC回收的，比如数据库连接，文件流等，所以需要我们自己做释放资源操作

#### 抛异常时需要注意的事项

1. 父类中的方法抛了异常，子类可抛可不抛
2. 父类中的方法没有抛异常，子类不能抛

重写尽量形式和父类保持一致

#### try-catch 和 throws 的时机

1. 如果处理异常后，还想让虚拟机继续运行，那么使用try-catch
2. 如果方法之间是递进关系，可以先throws，再在最后进行try-catch

#### 自定义异常

定义一个类，继承自Exception或者RuntimeException，重写构造方法即可

如果继承Exception，那么这个类就是编译时异常

如果继承RuntimeException，那么这个类就是运行时异常

##### 打印异常信息的三个方法

三者皆出自Throwable类

1. String toString()：获取异常简单信息
2. String getMessage()：获取异常信息
3. void printStackTrace()：获取异常信息，同时将异常信息输出到控制台

### Object类

所有类的根类，是java中的祖宗类

#### Object toString()

返回该对象的字符串表示形式

> getClass().getName() + '@' + Integer.toHexString(hashCode())

注意：

1. 如果没有重写toString方法，那么直接输出对象名时，默认调用的是toString方法，返回的是内存地址
2. 如果重写了toString方法，返回的是对象的被重写的内容

#### Object equals

比较的是两个对象的地址

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

对于 == , 如果是基本数据类型，那么比较的是值，如果是引用数据类型，那么比较的是地址

注意：

1. 如果没有重写Object中的equals方法，那么默认调用的是Object中的equals方法，比较的是地址
2. 如果重写了Object中的equals方法，那么比较的是对象中的内容

重写equals方法需要注意。

#### Object clone

复制一个属性值一样的新对象

被克隆的对象，必须实现Cloneable接口，然后重写克隆方法

### 经典接口

#### 比较大小：java.lang.Comparable接口

引用数据类型是不能比较大小的，为了解决这个问题，java给所有引用数据类型的大小比较，指定了一个标准，就是Comparable接口

```java
package java.lang;

public interface Comparable {
    int compareTo(Object o);
}
```

第一步：哪个类的对象要比较大小，哪个类就实现java.lang.Comparable接口，并重写方法

第二步：对象比较大小时，通过对象调用compareTo方法，根据方法的返回值决定谁大谁小。

- this对象，（调用compareTo方法的对象）减 指定对象（传入compareTo()的参数对象）大于0，返回正整数
- 小于0，返回负整数
- 等于0，返回0

## 模块十四 - API

### String字符串

#### String概述

1. String类是一个字符序列，用于表示和操作字符串
2. 特点：
   1. Java中所有的字符串都是以String实例化而来的对象。（凡是带双引号的都是String类的对象）
   2. 字符串是个常量，他们的值创建后就不能更改。之后，对字符串的增删操作，实际上是创建了一个新的字符串对象，然后将新的字符串对象赋给原来的字符串变量。
   3. String对象是不可变的，所以可以被共享。

#### String原理

1. jdk8：String是一个被final修饰的char数组。
2. jdk9开始：是一个被final修饰的byte数组。

一个char占两个字节，而一个byte占一个字节

优化了内存

#### String的创建

```java
String();
String(String s)
String(char[] value)
String(byte[] bytes)
```

简化形式：`String s = "abc";`

#### String面试题说明

```java
String s1 = "abc";
String s2 = "abc";
String s3 = new String("abc");
System.out.println(s1 == s2); // true
System.out.println(s1 == s3); // false
System.out.println(s2 == s3); // false
```

引用数据类型，比较的是地址，s1和s2是共享地址的，所以s1和s2比较时，返回true

1. String s1 = new String("abc"); 共有两个对象，一个是new本身，一个是"abc'
2. String s2 = new String("abc"); 共创建了一个或两个，要看abc有没有提前创建出来

```java
String s1 = "hello";
String s2 = "world";
String s3 = "helloworld"
String s4 = "hello" + "world";
String s5 = s1 + "world";
String s6 = s1 + s2;

System.out.println(s3 == s4); // true
System.out.println(s3 == s5); // false
System.out.println(s3 == s6); // false
```

#### String的常用方法

1. 判断方法，`boolean equals(String s)`|`boolean equalsIgnoreCase(String s)`
    - 实际开发中，为了防止出现空指针，一般会把**确切的值**作为对象，然后调用方法。
    - 或者使用`Objects.equals(String s1, String s2)`，该方法会自动判断空指针。
2. 获取功能：
   1. 获取字符串长度，调用`s.length()`。返回`int`
   2. 字符串拼接，调用`s.concat(String s)`。返回`String`
   3. 根据索引获取对应字符，调用`s.charAt(int index)`。返回`char`
   4. 获取指定字符串在大字符串中第一次出现的位置，调用`s.indexOf(String s)`。返回`int`
   5. 截取字符串，从指定索引开始截取到末尾，调用`s.substring(int index)`。返回`String`
   6. 截取字符串，从指定索引开始截取到指定索引结束，调用`s.substring(int start, int end)`。返回`String`（含头不含尾）
3. 转换功能：
   1. 将字符串转换为字符数组，调用`s.toCharArray()`。返回`char[]`
   2. 将字符串转换为字节数组，调用`s.getBytes()`。返回`byte[]`
   3. 替换字符，调用`s.replace(char oldChar, char newChar)`。返回`String`
4. 分割功能：
   1. `String[] split(String regex)`；regex表示正则表达式，返回`String[]`
5. 其他方法：
   1. `boolean isEmpty()`：判断字符串是否为空，返回`boolean`
   2. `String toLowerCase()`：将字符串转换为小写，返回`String`
   3. `String toUpperCase()`：将字符串转换为大写，返回`String`
   4. `boolean contains(String s)`：判断字符串是否包含指定字符串，返回`boolean`
   5. `boolean endsWith(String s)`：判断字符串是否以指定字符串结束，返回`boolean`
   6. `boolean startsWith(String s)`：判断字符串是否以指定字符串开始，返回`boolean`
   7. `String trim()`：去除字符串两端的空格，返回`String`

### StringBuilder

#### stringBuilder概述

一个可变的字符序列，此类提供了一个与StringBuffer兼容的API，但性能更好，但不保证同步（线程不安全）

作用：主要用于拼接字符串

为什么要使用？

1. String拼接字符有缺点：会不断产生新字符串对象。
2. StringBuilder自带一个缓存区，字符串可以改变。拼接字符串后，都会在缓存区中保存，不会产生新对象。

#### StringBuilder的特点

1. 底部自带缓存区，此缓存区是没有被final修饰的byte数组，默认长度为15
2. 如果超出了数组长度，数组会自动扩容，创建一个新长度的数组，然后将新数组的地址值重新赋值给老数组
3. 默认每次扩容老数组的2倍+2，如果超出了这个数组，会按照实际扩容为主。

#### StringBuilder的使用

1. 创建对象：`StringBuilder s = new StringBuilder()`
2. 常用方法：
   1. append(String s)：添加字符串，返回`StringBuilder`（是自己）
   2. reverse()：反转字符串，返回`StringBuilder`（是自己）
   3. toString()：将`StringBuilder`转换为`String`，返回`String`

## 模块十五 - API

### 数学相关类 - Math

1. 数学工具类
2. 主要用于数学运算
3. 特点
   1. 构造方法私有
   2. 方法都是静态的
4. 使用：`Math.abs(int a)`

#### Math常用方法

1. int abs(int a)：绝对值
2. double ceill(double a)：向上取整
3. double floor(double a)：向下取整
4. long round(double a)：四舍五入
5. int max(int a, int b)：取最大值
6. int min(int a, int b)：取最小值

### BigInteger类

1. BigInteger类，用于处理大整数（大于long类型的整数，一般称之为**对象**）
2. 构造：BigInteger(String s) - 参数的格式必须为数字形式

#### BigInteger常用方法

1. BigInteger add(BigInteger b)：加法
2. BigInteger subtract(BigInteger b)：减法
3. BigInteger multiply(BigInteger b)：乘法
4. BigInteger divide(BigInteger b)：除法

BigInteger有上限，上限是内存扛不住的，所以，我们可以认为BigInteger无上限。

### BigDecimal类

直接使用float或者double，会有精度丢失，所以，我们使用BigDecimal类。

作用：主要用来解决精度损失问题。

构造：BigDecimal(String s)，s表示数字字符串

#### BigDecimal常用方法

1. BigDecimal valueOf(double d)：将double类型的数据转换为BigDecimal对象
2. 其他方法和BigInteger大致一样

#### 过时方法解决

过时的方法可以使用，但是不建议使用。（底层会有注解@Deprecated）

### 日期相关类 - Date

表示特定的瞬间，精确到毫秒。

1000 ms = 1 s

时间戳原点：1970年1月1日0时0分0秒0毫秒（UNIX系统起始时间、格林威治时间、位于0度时区）

一个时区相差15度，时间相差一个小时。

北京：东八区、东经116

#### Date的使用

Date类有构造方法，但是一般使用Date()，获取当前时间。

### Calendar日历类

日历类，是一个抽象类，不能直接创建对象。

月份：0表示1月，11表示12月。

#### 需要知道的字段

YEAR：年

MOUTH：月

DAY_OF_MONTH：日

等。

### SimpleDateFormat日期格式化类

按照自己想要的格式，将日期对象转换成字符串。

构造：SimpleDateFormat(String pattern)

pattern代表自己制定的日期格式：字母不能改变，但是中间的连接符可以改变。

### jdk8新日期类

#### LocalDate 本地日期

是一个不可变的日期对象，表示日期，通常为年月日

#### Period和Duration类

period用于计算时间的差值

duration也用于计算时间差

#### DataTimeFormatter日期格式化类

### 工具类 System系统相关类

1. 概述：系统相关类，是一个工具类
2. 特点：
   1. 构造私有，不能利用构造方法new对象
   2. 方法都是静态的
3. 使用：System. 类名直接调用

#### System方法

1. static long currentTimeMillis()：获取当前时间毫秒值，返回long类型
2. static void exit(int status)：退出程序，参数为状态码，返回void
3. static void arrcopy(Object src, int srcPos, Object dest, int destPos, int length)：复制数组，返回T[]

### Arrays数组工具类

1. 概述：数组工具类，是一个工具类
2. 特点：
   1. 构造私有，不能利用构造方法new对象
   2. 方法都是静态的

#### Arrays方法

1. static void sort(int[] a)：对数组进行排序，返回void
2. static String toString(int[] a)：将数组转换为字符串，返回String
3. static int binarySearch(int[] a, int key)：二分查找，返回int
4. static void copyOf(int[] original, int newLength)：数组扩容，返回int[]

### 包装类

1. 概述：包装类，将基本数据类型转换为对象，对象可以调用方法。

我们需要将基本类型转成包装类，而让基本类型有了类的特性，能够调用其中的方法。

#### Integer类

Integer是int类型的包装类

不推荐使用了，但是还得学

#### 装箱与拆箱

1. 装箱：将基本类型转化成对应的包装类
2. 拆箱：将包装类转化成对应的基本类型

使用：Integer i = 5;

自动进行拆箱和装箱。

## 模块十六 - 多线程

### 多线程基本了解

#### 线程和进程

进程：在内存中执行的应用程序叫进程

线程：进程中最小的执行单元，负责当前进程中程序的运行

一个进程中至少要有一个线程，如果一个进程中有多个线程，那么这个进程就是多线程的。

简单理解：一个功能需要一条线程。

使用场景：软件中的耗时操作，所有的聊天软件，后台服务器

一个线程可以干一件事，同时就可以做多件事情，提高了CPU的利用率

#### 并发和并行

并行：在同一时刻，有多个执行在多个CPU上（很多人做很多事）

并发：在同一个时刻，有多个指令在单个CPU上，交替执行（一个人做多个事）

单核CPU通过高速切换执行的方式，造成了同时执行多个指令的效果。

#### CPU调度

1. 分时调度：所有线程轮流获取CPU的使用权，并且平均分配每个线程占用CPU的时间片。
2. 抢占式调度：多个线程轮流抢占获取CPU的使用权，并且优先级高的线程优先获取CPU的使用权。

java程序，是抢占式调度。

#### 主线程

CPU和内存之间，专门为main方法开辟和服务的线程。

### 创建线程方式

#### 第一种方式 - 继承 Thread类

1. 定义一个类，继承Thread
2. 重写run方法，在run方法中设置线程任务（所谓的线程任务就是线程要完成的具体代码）
3. 去创建自定义线程类的对象
4. 调用Thread中的start方法，开启线程，jvm自动调用run方法

```java
package cn.foreveryang.thread;

public class Test {
    public static void main(String[] args) {
        // 创建线程对象
        MyThread t1 = new MyThread();
        t1.start();

        for (int i = 0; i < 10; i++) {
            System.out.println("Main ... " + i);
        }
    }
}
```

```java
package cn.foreveryang.thread;

public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("My Thread ... " + i);
        }
    }
}
```

#### 多线程原理

每创建一个线程，都会新创建一个线程栈

同一个线程对象不能连续使用start方法，如果想要再新建一个线程，需要创建新的线程对象

#### Thread中的方法

void start()：启动线程，调用当前线程的run方法

void run()：线程任务，线程要完成的具体代码（需要重写）

String getName()：获取线程名称

void setName(String name)：设置线程名称

static Thread currentThread()：获取当前线程对象

static void sleep(long millis)：让当前线程休眠，单位毫秒

在重写的run方法中有异常只能try，不能throws

因为继承的Thread类中run方法没有抛出异常，所以不能throws

#### Thread类中的其他方法

void setPriority(int newPriority)：设置线程优先级，1-10

优先级越高，越容易使用CPU

int getPriority()：获取线程优先级

void setDaemon(boolean daemon)：设置线程为守护线程，默认为用户线程

static void yield()：让当前线程释放CPU，让CPU去执行其他线程

void join()：插入线程或插队线程

##### 线程优先级

Thread.MIN_PRIORITY：1

Thread.NORM_PRIORITY：5

Thread.MAX_PRIORITY：10

#### 守护线程

当线程为守护线程时，所有用户线程执行完毕，守护线程也会执行完毕

使用场景：QQ聊天时，

#### 礼让线程

让两个线程尽可能交替运行。

注意：只是尽可能的平衡，不是绝对的交替

#### 插入线程

### 创建线程方式二 - 实现Runnable接口

1. 创建一个类，实现Runnable接口
2. 重写run方法，设置线程任务
3. 利用Thread的构造方法，Thread(Runnable target)，创建Thread对象，将自定义的类的实例作为参数传递
4. 调用Thread的start方法，开启新线程，执行run方法

### 两种实现多线程的方式区别

1. 继承Thread类：单继承，有局限
2. 实现Runnable接口：多继承，可以有多个父类

### 创建线程方式三 - 匿名内部类创建多线程

匿名多线程是在实现Runnable接口的基础上的

```java
new Thread (new Runnable() {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("My Thread ... " + i);
        }
    }
}).start();
```

### 线程安全问题

当多个线程访问同一个资源时，导致了资源有问题

解决方法：进行上锁

#### 同步代码块

使用`synchronized`关键字

```java
synchronized (注意对象) {
    线程可能出现不安全的代码
}
```

1. 任意对象，就是我们的锁对象
2. 执行：一个线程拿到锁之后，会进入到同步代码块中执行，在此期间，其他线程拿不到锁，就进不去同步代码块，需要在同步代码块外等待排队

#### 同步方法

##### 非静态同步方法

```java
修饰符 synchronized 返回值类型 方法名(参数列表) {

}
```

非静态的同步方法，默认锁是this

### 死锁和线程状态

#### 死锁

两个或者两个以上的线程，因争夺资源而互相等待，造成线程的阻塞，最终导致所有线程都处于阻塞状态，造成系统假死

#### 线程生命周期

1. 新建New
2. 可运行Runnable
3. 锁阻塞Blocked
4. 无限等待Waiting
5. 计时等待Timed Waiting
6. 被终止Terminated

##### sleep和wait的区别

sleep：线程睡眠，在睡眠的过程中，线程不会释放锁，其他的线程无法抢占他的锁，设置的时间一到，自动醒来，继续执行

wait：线程等待，等待的过程中会释放锁，其他线程就有可能抢到锁，如果被唤醒，则会和其他线程抢锁

##### notify

notify会唤醒正在等待的线程，一次只能唤醒一条等待的线程，如果多条线程正在等待，notify就会随机唤醒一条线程


